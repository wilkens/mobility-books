View(final.df)
final.df$agreement
nrow(final.df$agreement == 1)
length(final.df$agreement == 1)
length(which(final.df$agreement == 1))
table(final.df$agreement)
table(final.df$answer.moral)
final.df$answer.moral
indices <- grepl("^News_(3[2-9]|4[0-9]|5[0-9]|6[0-3])$", final.df$Input.index)
if (any(indices)) {
count <- sum(indices)
new_labels <- sprintf("NewsChinese_%02d", 1:count)
# Replace the elements in the original vector
final.df$Input.index[indices] <- new_labels
}
modified_strings <- sub("_.*", "", final.df$Input.index)
final.df$genre<-modified_strings
table(final.df$genre)
final.sub<-final.df[final.df$agreement > 1,]
library(dplyr)
library(readr)
library(tidyr)
filtered_data <- select(final.sub, genre, answer.moral)
View(filtered_data)
gpt_moral_counts <- filtered_data %>%
filter(answer.moral == "GPT_moral") %>%
count(genre, name = "GPT_moral_count")
gpt_moral_counts
test<-final.df[final.df$genre == "Book",]
View(test)
test$answer.moral
test2<-a[a$story_type == "Book",]
table(test2$moral__best)
View(test2)
table(test2$Input.index)
i=1
sub<-test2[test2$Input.index == levels(factor(test2$Input.index))[i],]
View(sub)
sub$moral__best
test.df<-NULL
for (i in 1:nrow(test2)){
sub<-test2[test2$Input.index == levels(factor(test2$Input.index))[i],]
answer<-names(max(table(sub$moral__best)))
temp.df<-data.frame(i,answer)
test.df<-rbind(test.df, temp.df)
}
names(max(table(sub$moral__best)))
answer<-names(sort(table(sub$moral__best), decreasing = T))
answer
test.df<-NULL
for (i in 1:nrow(test2)){
sub<-test2[test2$Input.index == levels(factor(test2$Input.index))[i],]
if (length(table(sub$moral__best))){
answer<-names(sort(table(sub$moral__best), decreasing = T))
temp.df<-data.frame(i,answer)
test.df<-rbind(test.df, temp.df)
}
}
View(test.df)
i=1
sub<-test2[test2$Input.index == levels(factor(test2$Input.index))[i],]
answer<-names(sort(table(sub$moral__best), decreasing = T))[1]
answer
names(sort(table(sub$moral__best), decreasing = T))
test.df<-NULL
for (i in 1:nrow(test2)){
sub<-test2[test2$Input.index == levels(factor(test2$Input.index))[i],]
if (length(table(sub$moral__best)) < 3){
answer<-names(sort(table(sub$moral__best), decreasing = T))[1]
temp.df<-data.frame(i,answer)
test.df<-rbind(test.df, temp.df)
}
}
length(table(sub$moral__best)) < 3
i
sub<-test2[test2$Input.index == levels(factor(test2$Input.index))[i],]
View(sub)
nrow(test2)
sub<-test2[which(test2$Input.index == levels(factor(test2$Input.index))[i]),]
View(sub)
test2$Input.index
levels(factor(test2$Input.index))[i]
test.df<-NULL
for (i in 1:nlevels(factor(test2$Input.index))){
sub<-test2[which(test2$Input.index == levels(factor(test2$Input.index))[i]),]
if (length(table(sub$moral__best)) < 3){
answer<-names(sort(table(sub$moral__best), decreasing = T))[1]
temp.df<-data.frame(i,answer)
test.df<-rbind(test.df, temp.df)
}
}
test.df<-NULL
for (i in 1:nlevels(factor(test2$Input.index))){
sub<-test2[which(test2$Input.index == levels(factor(test2$Input.index))[i]),]
if (length(table(sub$moral__best)) < 3){
answer<-names(sort(table(sub$moral__best), decreasing = T))[1]
temp.df<-data.frame(i,answer)
test.df<-rbind(test.df, temp.df)
}
}
View(test.df)
table(test.df$answer)
i
i=1
sub<-a[which(a$Input.index == levels(factor(a$Input.index))[i]),]
length(table(sub$moral__best)) < 3
length(table(sub$moral__best))
agreement<-4-length(table(sub$moral__best))
agreement
answer.moral<-names(sort(table(sub$moral__best), decreasing = T))[1]
answer.moral
final.df<-NULL
for (i in 1:nlevels(factor(a$Input.index))){
sub<-a[which(a$Input.index == levels(factor(a$Input.index))[i]),]
if (length(table(sub$moral__best)) < 3){
answer.moral<-names(sort(table(sub$moral__best), decreasing = T))[1]
agreement<-4-length(table(sub$moral__best))
} else {
agreement<-1
answer.moral<-NA
}
sub<-sub[1,]
sub$agreement<-agreement
sub$answer.moral<-answer.moral
final.df<-rbind(final.df, sub)
}
table(final.df$agreement)
table(final.df$answer.moral)
indices <- grepl("^News_(3[2-9]|4[0-9]|5[0-9]|6[0-3])$", final.df$Input.index)
if (any(indices)) {
count <- sum(indices)
new_labels <- sprintf("NewsChinese_%02d", 1:count)
# Replace the elements in the original vector
final.df$Input.index[indices] <- new_labels
}
modified_strings <- sub("_.*", "", final.df$Input.index)
final.df$genre<-modified_strings
table(final.df$genre)
final.sub<-final.df[final.df$agreement > 1,]
library(dplyr)
library(readr)
library(tidyr)
filtered_data <- select(final.sub, genre, answer.moral)
gpt_moral_counts <- filtered_data %>%
filter(answer.moral == "GPT_moral") %>%
count(genre, name = "GPT_moral_count")
total_counts <- filtered_data %>%
count(genre, name = "total_count")
genre_comparison <- left_join(gpt_moral_counts, total_counts, by = "genre")
genre_comparison <- mutate(genre_comparison, proportion = GPT_moral_count / total_count)
print(genre_comparison)
contingency_table <- select(genre_comparison, genre, GPT_moral_count, total_count)
results <- data.frame(
genre = character(),
chi_square_statistic = numeric(),
p_value = numeric(),
stringsAsFactors = FALSE
)
data<-contingency_table
for(i in 1:nrow(data)) {
observed_GPT_moral <- data$GPT_moral_count[i]
total_observations <- data$total_count[i]
expected_GPT_moral <- total_observations * (1/3)
expected_not_GPT_moral <- total_observations * (2/3)
observed_counts <- c(observed_GPT_moral, total_observations - observed_GPT_moral)
expected_counts <- c(expected_GPT_moral, expected_not_GPT_moral)
# Perform chi-square goodness of fit test
test_result <- chisq.test(observed_counts, p = expected_counts / sum(expected_counts))
#store results
results <- rbind(results, data.frame(
genre = data$genre[i],
chi_square_statistic = test_result$statistic,
p_value = test_result$p.value
))
}
data<-cbind(data, results[,2:3])
data$proportion<-data$GPT_moral_count/data$total_count
View(data)
observed_GPT_moral <- sum(data$GPT_moral_count)   # This should be your observed count of "GPT_moral"
total_observations <- sum(data$total_count)   # Total number of observations
expected_GPT_moral <- total_observations * (1/3)
expected_not_GPT_moral <- total_observations * (2/3)
observed_counts <- c(observed_GPT_moral, total_observations - observed_GPT_moral)
# Put expected counts into a vector
expected_counts <- c(expected_GPT_moral, expected_not_GPT_moral)
chisq.test(observed_counts, p = expected_counts / sum(expected_counts))
View(data)
View(a)
a$Input.GPT_moral[1]
a$Input.GPT_moral[145]
a$Input.index[145]
a$Input.index[grep("News", a$Input.index)]
a$Input.index[grepl("News", a$Input.index)]
grep("News", a$Input.index)
a$Input.index[193]
a$Input.GPT_moral[193]
setwd("/Users/akpiper/Desktop")
# Define the keywords list (assuming you have already read them into a variable `keywords`)
keywords<-read.csv("some.txt")
View(keywords)
# Define the keywords list (assuming you have already read them into a variable `keywords`)
keywords<-read.csv("some.txt", header=F)
categories <- list(
Economic = c("financial", "economic", "fiscal", "profits", "transitioning", "corporations",
"investment", "market", "trade", "development", "entrepreneurship", "industry"),
Community = c("community", "public", "mutual", "social", "collaborative", "civic",
"civilization", "communities", "engagement", "participation", "cooperation",
"integration", "cultural", "regional", "local"),
Governance = c("governance", "policy", "policies", "regulations", "law", "political",
"legislation", "authority", "government", "legal", "dialogue", "compliance"),
Environmental_Conservation_and_Management = c("environmental", "conservation", "ecological",
"green", "sustainability", "eco", "preservation",
"protection", "restoration", "natural"),
Innovation_and_Technology = c("innovation", "technology", "technological", "digital",
"modernization", "innovating", "creativity", "solutions"),
Adaptation_and_Preparedness = c("adaptation", "preparedness", "resilience", "adapting",
"mitigating", "response", "recovery", "emergency", "crisis"),
Uncategorizable = character()  # Initialize empty
)
categorize_keywords <- function(word, categories) {
for (cat_name in names(categories)) {
if (tolower(word) %in% tolower(categories[[cat_name]])) {
return(cat_name)
}
}
return("Uncategorizable")
}
categorized <- sapply(keywords, categorize_keywords, categories)
data.df<-as.data.frame(categories)
df_categories <- stack(categories)
View(df_categories)
#which keywords are not in table
test<-keywords[!keywords %in% df_categories$values]
View(test)
df_categories$values
View(df_categories)
a<-read.csv(gzfile("ALL_CharData_AP_MW_12.csv.gz"))
setwd("/Users/akpiper/Documents/GitHub/mobility-books/data/derived")
a<-read.csv(gzfile("ALL_CharData_AP_MW_12.csv.gz"))
c<-a[a$collection == "conlit",]
#variables
measures<-c("dist_miles", "gpe_places_total", "nongpe_places_total",
"deixis_count_perplace", "semantic_dist_mean")
#more intuitive names used for measures
measure.names<-c("Distance", "GPEs", "NonGPEs",
"Deictics","Semantic Dist", "NON_GPE Ratio")
#social classes we are analyzings
classes<-c("Fictionality", "Prestige", "Youth", "Female Character")
splitElements2 <- function(input_column) {
# Remove the square brackets at the beginning and end of each string in the column
cleaned_text <- gsub("^\\[|\\]$", "", input_column)
# Split each string into a list of elements based on ', ' and remove single quotes
elements_list <- lapply(strsplit(cleaned_text, "', '"), function(x) gsub("'", "", x))
# Convert the list of elements into a data frame
result_df <- unlist(elements_list)
return(result_df)
}
remove_words <- function(text_vector, remove) {
# Construct a single regex pattern that matches any word in the remove vector
pattern <- paste0("\\b(", paste(remove, collapse="|"), ")\\b")
# Replace matched words with empty string
cleaned_text <- gsub(pattern, "", text_vector)
# Remove leading and trailing whitespace
return(trimws(cleaned_text))
}
fic<-c[c$Category == "FIC",]
list_of_vectors <- lapply(fic$gpe_sequences, splitElements2)
place.v<-unlist(list_of_vectors)
top.v<-names(sort(table(place.v), decreasing = T)[1:5])
top.v
top.plus1.v<-vector(mode="character", length=length(top.v))
for (i in 1:length(top.v)){
next.v<-place.v[(which(place.v == top.v[i])+1)]
top.plus1.v[i]<-paste(names(sort(table(next.v), decreasing = T)[1:5]), collapse = ",")
}
df<-data.frame(top.v, top.plus1.v)
colnames(df)<-c("Top Places", "Next Places")
df
place.v
top.v
View(fic)
list_of_vectors <- lapply(fic$gpe_sequences, splitElements2)
list_of_vectors
list_of_vectors[1]
place.v[1:10]
top.plus1.v<-vector(mode="character", length=length(top.v))
top.plus1.v
find_next_place <- function(list_of_vectors, input_vector) {
# Initialize an empty vector to store the results
output_vector <- c()
# Loop over each element in the input vector
for (input_place in input_vector) {
# Initialize a temporary vector to store the next places for the current input place
temp_vector <- c()
# Loop over each vector in the list
for (place_vector in list_of_vectors) {
# Find the index of the input place in the current vector
index <- which(place_vector == input_place)
# If the input place is found and it is not the last element, get the next place
if (length(index) > 0 && index < length(place_vector)) {
next_place <- place_vector[index + 1]
# Append the next place to the temporary vector
temp_vector <- c(temp_vector, next_place)
}
}
# Combine the temporary vector into the output vector
output_vector <- c(output_vector, temp_vector)
}
return(output_vector)
}
list_of_vectors <- list(
c("Paris", "London", "Berlin"),
c("Rome", "Madrid", "Paris"),
c("Berlin", "Paris", "London")
)
list_of_vectors
input_vector <- c("Paris", "Berlin")
output <- find_next_place(list_of_vectors, input_vector)
output
find_next_place <- function(list_of_vectors, input_vector) {
# Initialize an empty list to store the results
output_list <- list()
# Loop over each element in the input vector
for (input_place in input_vector) {
# Initialize a temporary vector to store the next places for the current input place
temp_vector <- c()
# Loop over each vector in the list
for (place_vector in list_of_vectors) {
# Find the index of the input place in the current vector
index <- which(place_vector == input_place)
# If the input place is found and it is not the last element, get the next place
if (length(index) > 0 && index < length(place_vector)) {
next_place <- place_vector[index + 1]
# Append the next place to the temporary vector
temp_vector <- c(temp_vector, next_place)
}
}
# Store the temporary vector in the output list
output_list[[input_place]] <- temp_vector
}
return(output_list)
}
list_of_vectors <- list(
c("Paris", "London", "Berlin"),
c("Rome", "Madrid", "Paris"),
c("Berlin", "Paris", "London")
)
input_vector <- c("Paris", "Berlin")
output <- find_next_place(list_of_vectors, input_vector)
output
get_top_five <- function(output_list) {
# Initialize an empty list to store the results
top_five_list <- list()
# Loop over each element in the output list
for (input_place in names(output_list)) {
# Create a frequency table for the current vector
freq_table <- table(output_list[[input_place]])
# Sort the frequency table in descending order
sorted_freq_table <- sort(freq_table, decreasing = TRUE)
# Get the top five items
top_five <- head(sorted_freq_table, 5)
# Store the top five items in the output list
top_five_list[[input_place]] <- top_five
}
return(top_five_list)
}
list_of_vectors <- list(
c("Paris", "London", "Berlin"),
c("Rome", "Madrid", "Paris"),
c("Berlin", "Paris", "London")
)
input_vector <- c("Paris", "Berlin")
output <- find_next_place(list_of_vectors, input_vector)
top_five_output <- get_top_five(output)
top_five_output
top.v
#actual
input_vector<-top.v
output <- find_next_place(list_of_vectors, input_vector)
output
input_vector<-top.v
input_vector
output <- find_next_place(list_of_vectors, input_vector)
output
list_of_vectors <- lapply(fic$gpe_sequences, splitElements2)
output <- find_next_place(list_of_vectors, input_vector)
list_of_vectors
input_vector
output <- find_next_place(list_of_vectors, input_vector)
find_next_place <- function(list_of_vectors, input_vector) {
# Initialize an empty list to store the results
output_list <- list()
# Loop over each element in the input vector
for (input_place in input_vector) {
# Initialize a temporary vector to store the next places for the current input place
temp_vector <- c()
# Loop over each vector in the list
for (place_vector in list_of_vectors) {
# Find the indices of the input place in the current vector
indices <- which(place_vector == input_place)
# Loop through each index and get the next place if not the last element
for (index in indices) {
if (index < length(place_vector)) {
next_place <- place_vector[index + 1]
# Append the next place to the temporary vector
temp_vector <- c(temp_vector, next_place)
}
}
}
# Store the temporary vector in the output list
output_list[[input_place]] <- temp_vector
}
return(output_list)
}
# Function to get the top five items in descending order
get_top_five <- function(output_list) {
# Initialize an empty list to store the results
top_five_list <- list()
# Loop over each element in the output list
for (input_place in names(output_list)) {
# Create a frequency table for the current vector
freq_table <- table(output_list[[input_place]])
# Sort the frequency table in descending order
sorted_freq_table <- sort(freq_table, decreasing = TRUE)
# Get the top five items
top_five <- head(sorted_freq_table, 5)
# Store the top five items in the output list
top_five_list[[input_place]] <- top_five
}
return(top_five_list)
}
list_of_vectors <- list(
c("Paris", "London", "Berlin"),
c("Rome", "Madrid", "Paris"),
c("Berlin", "Paris", "London")
)
input_vector <- c("Paris", "Berlin")
output <- find_next_place(list_of_vectors, input_vector)
top_five_output <- get_top_five(output, 5)
get_top_five <- function(output_list, n) {
# Initialize an empty list to store the results
top_five_list <- list()
# Loop over each element in the output list
for (input_place in names(output_list)) {
# Create a frequency table for the current vector
freq_table <- table(output_list[[input_place]])
# Sort the frequency table in descending order
sorted_freq_table <- sort(freq_table, decreasing = TRUE)
# Get the top five items
top_five <- head(sorted_freq_table, n)
# Store the top five items in the output list
top_five_list[[input_place]] <- top_five
}
return(top_five_list)
}
top_five_output <- get_top_five(output, 5)
top_five_output
list_of_vectors <- lapply(fic$gpe_sequences, splitElements2)
input_vector<-top.v
output <- find_next_place(list_of_vectors, input_vector)
output
top_five_output <- get_top_five(output, 5)
top_five_output
top_five_output <- get_top_five(output, 10)
top_five_output
top_five_to_df <- function(top_five_output) {
# Initialize an empty list to store the results
df_list <- list()
# Loop over each element in the top_five_output list
for (input_place in names(top_five_output)) {
# Extract the names of the places (excluding the counts)
place_names <- names(top_five_output[[input_place]])
# Create a data frame row with the input place name and the place names
df_row <- data.frame(input_place = input_place, matrix(place_names, nrow = 1))
# Append the data frame row to the list
df_list <- append(df_list, list(df_row))
}
# Combine all rows into a single data frame
final_df <- bind_rows(df_list)
return(final_df)
}
df<-top_five_to_df(top_five_output)
df
View(df)
setwd("/Users/akpiper/Documents/GitHub/mobility-books/data/derived")
write.csv(df, file="MostCommonPlacesAndNextHop.csv", row.names = F)
stop<-stopwords("en")
library(tm)
stop<-stopwords("en")
stop<-unlist(strsplit(stop,"[[:punct:]]"))
stop<-unique(stop)
list_of_vectors <- lapply(fic$nongpe_places_cleaned, splitElements2)
list_of_vectors
places<-tolower(list_of_vectors)
places
clean_places <- function(vector, stop_words) {
# Convert to lower case
vector <- tolower(vector)
# Remove punctuation
vector <- gsub("[[:punct:]]", "", vector)
# Remove stopwords
vector <- removeWords(vector, stop_words)
# Remove white spaces
vector <- gsub("\\s+", " ", vector)
# Remove blanks
vector <- vector[vector != ""]
# Remove duplicates in sequence
#vector <- rle(vector)$values
return(vector)
}
gc()
gc()
